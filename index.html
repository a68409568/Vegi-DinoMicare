<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vegi Dinomicare</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>The Needs Of Seattle</h1>
    <p>And How Australia Can Help Fill Them.</p>
  </header>
  <main>
    <!-- Overview and instructions -->
    <section>
      <h2>Abstract</h2>
      <p>
        What are the needs of the city of Seattle? What are the strengths of the
        state of Australia? <br>
          How can we connect the strengths of Australia to improve the needs of
          the city of Seattle?
      </p>
    </section>
    <section>
      <h2>Let Us Begin</h2>
      <ol>
        <li>
          About @README
          <a href="URL">https://github.com/a68409568/Vegi-DinoMicare</a>
        </li>
        <li>Press '‚Üë' or 'W' to Jump</li>
        <li>Press '‚Üì' or 'S' to Duck</li>
      </ol>
    </section>
    <!-- Game Box Set Up -->
    <section id="dino-game">
      <h2>Ready. Set. Begin. (Or Play if thoust already beguneth)</h2>
      <div class="dino-placeholder wide blue-border">
        <div id="game">
          <div id="dino">üê®</div>
        </div>
        <div id="score">Score: 0</div>
        <button id="restart">Restart</button>
      </div>
    </section>
  </main>
  <footer>
    <p>&copy; 2025 Vegi Dinomicare</p>
  </footer>

  <-- 
    Begin game code
    -->
  <script>
    // Creates the references for objects used in the game
    const game = document.getElementById('game');
    const dino = document.getElementById('dino');
    const scoreElem = document.getElementById('score');
    const restartBtn = document.getElementById('restart');

    // Game state and constants
    let dinoY = 0, dinoVelY = 0, gravity = 0.9, jumping = false, ducking = false;
    let score = 0, running = true, obstacles = [], gameLoopId;
    const dinoHeight = 40, dinoStep = dinoHeight, dinoJumpVel = 14, groundY = dinoHeight;
    const gameWidth = 900, gameHeight = 200; // Wide game area for horizontal coverage
    const dinoRightMargin = 70; // Distance from right edge for koala
    const obstacleSpeed = 2, obstacleFreq = 2300;

    // Obstacle text options
    const australiaStatements = [
      "placeholder australia", "placeholder australia",", "placeholder australia",", "placeholder australia",
    ];
    let statementIndex = 0;

    // Set up the game box size
    game.style.width = gameWidth + "px";
    game.style.height = gameHeight + "px";
    // Position koala on the right side
    dino.style.right = dinoRightMargin + "px";
    dino.style.left = "auto";
    dino.style.bottom = groundY + "px";
    dino.style.position = "absolute";

    // Reset all game variables and UI
    function resetGameVars() {
      dinoY = 0;
      dinoVelY = 0;
      jumping = false;
      ducking = false;
      score = 0;
      running = true;
      statementIndex = 0;
      dino.style.bottom = groundY + 'px';
      dino.classList.remove('duck');
      dino.style.transform = '';
      scoreElem.textContent = "Score: 0";
    }

    // Remove all current obstacles
    function removeAllObstacles() {
      document.querySelectorAll('.obstacle').forEach(o => o.remove());
    }

    // Handle jumping
    function jump() {
      if (!jumping && !ducking) {
        dinoVelY = dinoJumpVel;
        jumping = true;
      }
    }

    // Handle ducking
    function duck(state) {
      ducking = state;
      dino.classList.toggle('duck', ducking);
    }

    // Move koala vertically with up/down or W/S
    function moveDinoVert(dir) {
      let curr = parseInt(dino.style.bottom) || groundY;
      let newBottom = curr + dir * dinoStep;
      if (newBottom >= 0 && newBottom <= gameHeight - dinoHeight) {
        dino.style.bottom = newBottom + 'px';
      }
    }

    // Keyboard controls into vertical movement
    document.addEventListener('keydown', e => {
      if (!running) return;
      if (e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') moveDinoVert(1);
      if (e.code === 'ArrowDown' || e.key === 's' || e.key === 'S') moveDinoVert(-1);
    });

    // koala vertical movement
    function updateDino() {
      if (jumping) {
        dinoY += dinoVelY;
        dinoVelY -= gravity;
        if (dinoY <= 0) {
          dinoY = 0;
          jumping = false;
        }
        dino.style.transform = `translateY(${-dinoY}px)`;
      }
    }

    // Get next statement for obstacle w/ final return if no more
    function getNextStatement() {
      if (statementIndex >= australiaStatements.length) return null;
      const text = australiaStatements[statementIndex];
      statementIndex++;
      return text;
    }

    // Create an 'obstacle' as text that slides left-to-right
    function createObstacle() {
      if (!running) return;
      const nextText = getNextStatement();
      if (!nextText) return;
      const obs = document.createElement('div');
      obs.className = 'obstacle';
      obs.innerText = nextText;
      obs.style.left = "0px";
      // Random vertical position, 3 possible
      const possibleBottoms = [0, dinoHeight, dinoHeight * 2];
      let obsBottom = possibleBottoms[Math.floor(Math.random() * possibleBottoms.length)];
      obs.style.bottom = obsBottom + 'px';
      game.appendChild(obs);

      let obsPos = 0;
      function moveObs() {
        if (!running) return obs.remove();
        obsPos += obstacleSpeed;
        obs.style.left = obsPos + 'px';

        // Collision detection
        let dinoRect = dino.getBoundingClientRect();
        let obsRect = obs.getBoundingClientRect();
        if (
          obsRect.right > dinoRect.left &&
          obsRect.left < dinoRect.right &&
          obsRect.bottom > dinoRect.top &&
          obsRect.top < dinoRect.bottom
        ) {
          running = false;
          scoreElem.textContent = `Game Over! Final Score: ${score}`;
          obs.remove();
          return;
        }

        if (obsPos > gameWidth - dinoRightMargin) {
          game.removeChild(obs);
          score++;
          scoreElem.textContent = `Score: ${score}`;
        } else {
          requestAnimationFrame(moveObs);
        }
      }
      moveObs();
    }

    // Main game loop
    function gameLoop() {
      if (!running) return;
      updateDino();
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    // Start obstacles generation
    let obstacleInterval;
    function startObstacles() {
      obstacleInterval = setInterval(() => {
        if (!running) return;
        if (statementIndex < australiaStatements.length) {
          createObstacle();
        }
      }, obstacleFreq);
    }
    function stopObstacles() {
      clearInterval(obstacleInterval);
    }

    // Start or restart the game
    function startGame() {
      resetGameVars();
      removeAllObstacles();
      stopObstacles();
      startObstacles();
      gameLoop();
    }

    // Restart button
    restartBtn.addEventListener('click', () => {
      running = false;
      stopObstacles();
      cancelAnimationFrame(gameLoopId);
      setTimeout(() => {
        startGame();
      }, 50);
    });

    // Initial setup and start
    startGame();
  </script>
</body>
</html>
